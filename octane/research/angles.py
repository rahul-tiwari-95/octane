"""AngleGenerator — multi-angle sub-query expansion for deep research.

Session 18B: Deep Research Mode.

Given a research topic, produces a set of search angles that together
cover the topic from multiple perspectives. Each angle is an independent
search query passed to the WebAgent in parallel.

Depth tiers:
    shallow     — 2 angles  (fastest, good for quick refreshes)
    deep        — 4 angles  (default; balanced coverage)
    exhaustive  — 8 angles  (most thorough; slowest)

Angles are generated by an LLM if available; otherwise a deterministic
keyword-expansion fallback is used so the system works offline.

Usage::

    from octane.research.angles import AngleGenerator

    gen = AngleGenerator(bodega=bodega_client)   # bodega optional
    angles = await gen.generate("NVDA earnings outlook", depth="deep")
    # → [
    #     {"query": "NVDA Q4 2025 earnings results", "angle": "earnings"},
    #     {"query": "NVIDIA AI chip demand 2025", "angle": "market"},
    #     ...
    #   ]
"""

from __future__ import annotations

import json
import re

import structlog

logger = structlog.get_logger().bind(component="research.angles")

# Depth → number of angles
DEPTH_ANGLES: dict[str, int] = {
    "shallow": 2,
    "deep": 4,
    "exhaustive": 8,
}

_ANGLE_SYSTEM = """\
You are a financial research analyst and expert query planner.
Given a research topic, return a JSON array of search angle objects.

Each object must have:
  - "query":  a focused, specific search string (≤15 words)
  - "angle":  one of: earnings, market, sentiment, macro, risk, technical, \
regulatory, competitive, product, insider

Rules:
- Each angle must be meaningfully different — different perspective, not synonyms.
- Prefer recent, time-bounded queries (include year when relevant).
- For financial topics always include at least: earnings, market, sentiment.
- Avoid generic phrases like "latest news about X".
- Return ONLY valid JSON array. No prose, no markdown fences.

Example output for topic "NVDA earnings outlook":
[
  {"query": "NVIDIA Q4 2025 earnings revenue beat miss", "angle": "earnings"},
  {"query": "NVIDIA AI chip demand data center 2025", "angle": "market"},
  {"query": "NVDA analyst price target upgrade downgrade 2025", "angle": "sentiment"},
  {"query": "NVIDIA AI circular financing risk concerns 2025", "angle": "risk"}
]"""


class AngleGenerator:
    """Generates multi-angle sub-queries for a research topic.

    Args:
        bodega: Optional ``BodegaInferenceClient``. When provided, uses the LLM
                to produce semantically rich angles. When None, falls back to
                deterministic keyword expansion.
    """

    def __init__(self, bodega=None) -> None:
        self._bodega = bodega

    async def generate(self, topic: str, depth: str = "deep") -> list[dict[str, str]]:
        """Return a list of angle dicts for *topic*.

        Args:
            topic: Research topic string.
            depth: One of ``"shallow"``, ``"deep"``, ``"exhaustive"``.

        Returns:
            List of ``{"query": str, "angle": str}`` dicts.
        """
        n = DEPTH_ANGLES.get(depth, DEPTH_ANGLES["deep"])

        if self._bodega is not None:
            try:
                angles = await self._llm_angles(topic, n)
                if angles:
                    return angles[:n]
            except Exception as exc:
                logger.warning("angle_llm_failed", error=str(exc), fallback="keyword")

        return self._keyword_angles(topic, n)

    async def _llm_angles(self, topic: str, n: int) -> list[dict[str, str]]:
        """Generate angles via LLM."""
        from octane.utils.clock import today_str  # deferred import

        prompt = (
            f"Topic: {topic}\n"
            f"Today: {today_str()}\n"
            f"Generate exactly {n} search angles."
        )
        raw = await self._bodega.chat_simple(
            prompt=prompt,
            system=_ANGLE_SYSTEM,
            max_tokens=600,
            temperature=0.4,
        )
        return _parse_angles(raw)

    def _keyword_angles(self, topic: str, n: int) -> list[dict[str, str]]:
        """Deterministic fallback — expands topic with angle suffixes."""
        suffixes = [
            ("earnings revenue outlook {topic}", "earnings"),
            ("{topic} market analysis 2025", "market"),
            ("{topic} analyst sentiment forecast", "sentiment"),
            ("{topic} risk concerns regulatory", "risk"),
            ("{topic} competitive landscape rivals", "competitive"),
            ("{topic} product roadmap innovation", "product"),
            ("{topic} macro economic impact", "macro"),
            ("{topic} technical analysis price trend", "technical"),
        ]
        result = []
        for tmpl, angle in suffixes[:n]:
            q = tmpl.replace("{topic}", topic)
            result.append({"query": q, "angle": angle})
        return result


def _parse_angles(raw: str) -> list[dict[str, str]]:
    """Parse JSON angle array from LLM response; returns [] on failure."""
    try:
        # Strip markdown fences if present
        clean = re.sub(r"^```(?:json)?\s*|\s*```$", "", raw.strip(), flags=re.MULTILINE)
        data = json.loads(clean)
        if isinstance(data, list):
            valid = []
            for item in data:
                if isinstance(item, dict) and "query" in item:
                    valid.append({
                        "query": str(item["query"]),
                        "angle": str(item.get("angle", "general")),
                    })
            return valid
    except Exception as exc:
        logger.warning("angle_parse_failed", error=str(exc), raw_snippet=raw[:120])
    return []
